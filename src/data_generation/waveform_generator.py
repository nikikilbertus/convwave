"""
This module generates waveforms for compact binary coalescences.

One first generates a high level specification JSON file that only specifies
meta information such as the number of waveforms and from which ranges to
sample the parameters. Then we actually sample the parameters for the waveforms
and saves those in a big JSON file. Next, we generate all these specified
waveforms and save them together with the configuration file in an hdf file.
"""

from __future__ import absolute_import, print_function

import os
import json
import pylab
import numpy as np
import h5py
from tqdm import tqdm

from pycbc.waveform import get_td_waveform


def data_generation_pipeline(meta_config_file='../data/config.json',
                             sample_config_file='../data/sample_config.json',
                             sample_file='../data/samples.h5'):
    """
    Run through the whole data generation pipeline.

    Arguments:

        meta_config_file: Path of a JSON file created by `generate_meta_config`

        sample_config_file: Path where to store the sample config JSON file

        sample_file: Path where to store the samples hdf data file

    Given a meta config file, sample the specified waveform parameters, compute
    the waveforms and store them.
    """
    WaveformConfigGenerator(meta_config_file,
                            sample_config_file).generate_and_save_config()
    WaveformGenerator(sample_config_file,
                      sample_file).generate_and_save_waveforms()


class WaveformGenerator:
    """
    Compute waveforms.
    """

    def __init__(self, config_file, output_file):
        """
        Initialize a WaveformGenerator.

        Arguments:

            config_file: A JSON configuration file generated by
                         `WaveformConfigGenerator`

            output_file: File path where to store the created hdf file
        """
        self.config_file = config_file
        self.output_file = output_file
        print("Reading the configuration {}...".format(config_file), end=' ')
        with open(self.config_file, 'r') as f:
            self.config = json.loads(f.read())
        print("DONE")

    def generate_and_save_waveforms(self):
        """
        Generate and save all specified waveforms.
        """
        # How many waveforms do we have to generate
        n_samples = len(self.config['injections'])
        duration = self.config['meta']['duration']
        sample_rate = self.config['meta']['sample_rate']

        # Collect indices of failures during waveform generation
        # Sometimes the model just fail to compute the requested waveform.
        # This indicates that one should choose different parameter regions.
        failed = []
        # Compute the waveforms
        print("Generate the waveforms...", end=' ')
        # If the duration is smaller 0, all waveforms are kept in full length
        if duration > 0:
            N = int(duration * sample_rate)
            waveforms = np.zeros((n_samples, N))

            for i, conf in enumerate(tqdm(self.config['injections'])):
                x = np.zeros(N)
                try:
                    # Compute the current waveform
                    hp, cp = tuple(map(np.array, get_td_waveform(**conf)))
                    # Get the correct indices to inject it into the noise
                    inj_time = conf['injection_time']
                    Iembed, Isignal = self._get_embedding_indices(hp,
                                                                  inj_time,
                                                                  N)
                    x[Iembed] += hp[Isignal]
                except Exception as e:
                    # If waveform fails, remember the index
                    # and keep the waveform as all zeros
                    failed.append(i)
                    err = type(e).__name__
                    print("Failure {}\n during waveform {}: {}".format(err,
                                                                       i,
                                                                       conf))
                waveforms[i, :] = x
        else:
            waveforms_raw = []
            for i, conf in enumerate(tqdm(self.config['injections'])):
                try:
                    # Compute the current waveform
                    hp, cp = tuple(map(np.array, get_td_waveform(**conf)))
                    waveforms_raw.append(hp)

                    # Get the correct indices to inject it into the noise
                    inj_time = conf['injection_time']
                except Exception as e:
                    # If waveform fails, remember the index
                    # and keep the waveform as all zeros
                    waveforms_raw.append(np.zeros(1))
                    failed.append(i)
                    err = type(e).__name__
                    print("Failure {}\n during waveform {}: {}".format(err,
                                                                       i,
                                                                       conf))
            N = max(map(len, waveforms_raw))
            waveforms = np.zeros((n_samples, N))
            for i, x in enumerate(waveforms_raw):
                waveforms[i, :len(x)] = x
                inj_time = np.argmax(x) / float(N)
                self.config['injections'][i]['injection_time'] = inj_time
        print("DONE")

        print("Save everything to file...", end=' ')
        with h5py.File(self.output_file, 'w') as f:
            f['waveforms'] = waveforms
            f['config'] = np.string_(json.dumps(self.config))
            f['failed'] = failed
        print("DONE")

    def plot_waveform(self, index=0):
        """
        Plot a waveform.

        This is mostly just for testing and visualization.
        """
        fig = pylab.figure()
        with h5py.File(self.output_file, 'r') as f:
            x = f['X'][index, :]
        pylab.plot(x)
        pylab.ylabel('Strain')
        pylab.xlabel('Time')
        return fig

    def _get_embedding_indices(self, f, frac, N):
        """
        Return matching indices of background and waveform for superposition.

        The waveform generating functions generate waveforms of different
        length, depending on the input parameters. Together with a variable
        injection time with in the sample, the waveform could be too
        long or too short towards both sides. Hence computing the injection
        indices is not completely straight forward.

        This is highly non-trivial magic and after extensive testing I never
        want to have to open this box again.
        """
        ni = int(frac * N)
        nn = N - 1
        sn = len(f) - 1
        si = np.argmax(f)
        start = ni - si
        nl, sl = abs(start), 0
        if start < 0:
            nl, sl = sl, nl
        end = (nn - ni) - (sn - si)
        nr, sr = ni + sn - si, sn
        if end < 0:
            nr, sr = nn, si + nn - ni
        Iembed = range(nl, nr + 1)
        Isignal = range(sl, sr + 1)
        if len(Iembed) == 0 or len(Isignal) == 0:
            print('Could not find appropriate ranges:')
            print('noise length: {}, signal length: {}'.format(nn, sn))
            print('noise: {} : {}, signal: {} : {}'.format(nl, nr, sl, sr))
        return Iembed, Isignal


# -----------------------------------------------------------------------------
# ------------------------------  Generate a Waveform Configuration JSON File
# -----------------------------------------------------------------------------


class WaveformConfigGenerator:
    """
    Sample and save waveform parameters in a waveform configuration JSON file.
    """

    waveform_config = {}

    def __init__(self, meta_config_file, output_file):
        """
        Initialize the WaveformConfigGenerator.

        Arguments:

            meta_config_file: A meta configuration file as generated by
            `generate_meta_config`. This meta config file can be hand tuned.

            output_file: The sample_configuration file holding information
            about parameters of each individual waveform.
        """
        self.output_file = output_file
        self.meta_config_file = meta_config_file
        print("Load meta configuration...", end=' ')
        with open(self.meta_config_file, 'r') as f:
            self.meta_config = json.loads(f.read())
        print("DONE")
        self.n_samples = self.meta_config['n_samples']
        self.default_parameters = self.meta_config['default_parameters']
        self.update_list = self.meta_config['update_list']

    def generate_and_save_config(self):
        """
        Generate and save the configuration JSON file for the injections.
        """
        self.waveform_config.update(self._injections_spec())
        self.waveform_config.update({'meta': self.meta_config})
        print("Write configuration to {}...".format(self.output_file), end=' ')
        with open(self.output_file, 'w') as f:
            json.dump(self.waveform_config, f, sort_keys=True, indent=2)
        print("DONE")

    def _injections_spec(self):
        """
        Generate and return specification of the injection waveforms.
        """
        injections = []
        print("Sampling the waveform parameters...", end=' ')
        for i in range(self.n_samples):
            cp = self.default_parameters.copy()
            # Set the id first as counter
            cp.update({'id': i})
            # Update other values in the update list with new samples
            # Some magic to figure out how to sample the samples
            # Very bad style with eval and everything. Works. Wouldn't touch.
            for update, pars in self.update_list.iteritems():
                args = '("' + update + '", ' + str(pars) + ')'
                fname = 'self._sample_' + update + args
                cp.update(eval(fname))
            injections.append(cp)
        print("DONE")
        return {'injections': injections}

    def _sample_distance(self, key, pars):
        """
        Draw a random source distance.
        """
        return {key: self._uniform_in_range(pars[0], pars[1])}

    def _sample_masses(self, key, pars):
        """
        Draw random compact object masses.
        """
        mass1 = self._uniform_in_range(pars[0], pars[1])
        mass2 = self._uniform_in_range(pars[0], pars[1])
        return {'mass1': mass1, 'mass2': mass2}

    def _sample_injection_time(self, key, pars):
        """
        Draw a random injection time.
        """
        return {key: self._uniform_in_range(pars[0], pars[1])}

    def _uniform_in_range(self, lower_bound, upper_bound):
        """
        Draw uniformly distributed number in a given range.
        """
        return np.random.rand() * (upper_bound - lower_bound) + lower_bound


def generate_meta_config(output_file='../data/meta_config.json'):
    """
    Generate a meta configuration JSON file for the data generation pipeline.

    This spits out a valid template of a meta configuration file as the one
    required by the `WaveformConfigGenerator`. Just run this once to have a
    valid template and then you can go ahead an tweak the individual numbers in
    that template. All the defaults are considered sane choices.
    """
    print("Generate meta config file {}...".format(output_file), end=' ')
    n_samples = 1024
    # If the duration is < 0.0 the whole waveform will be used.
    # All waveforms will be padded to the right with zeros to the length of the
    # longest generated waveform.
    # Then the injection times are overriden(!) in the config file coming with
    # the output h5 file with the fraction where the maximum of the waveform
    # lies within the whole sample.
    duration = -1.
    sample_rate = 4096
    # Default parameters passed to simulator in case a parameter is not sampled

    # Possible approximants: ['TaylorEt', 'SEOBNRv3_opt', 'IMRPhenomA',
    # 'IMRPhenomC', 'IMRPhenomB', 'EOBNRv2', 'SEOBNRv4_opt', 'PhenSpinTaylor',
    # 'PhenSpinTaylorRD', 'NR_hdf5', 'SEOBNRv3_pert', 'EOBNRv2HM',
    # 'SpinTaylorT4', 'TaylorT1', 'TaylorT3', 'TaylorT2', 'HGimri', 'TaylorT4',
    # 'IMRPhenomD', 'IMRPhenomPv2', 'SEOBNRv1', 'SpinDominatedWf', 'SEOBNRv3',
    # 'SEOBNRv2', 'SpinTaylorT1', 'SEOBNRv4', 'SpinTaylorT2', 'EccentricTD',
    # 'SEOBNRv2_opt', 'SEOBNRv3_opt_rk4']
    default_parameters = {
        'mass1': 1.0,
        'mass2': 1.0,
        'spin1z': 0.0,
        'spin2z': 0.0,
        'lambda1': 0.0,
        'lambda2': 0.0,
        'distance': 1000.0,
        'coa_phase': 0.0,
        'inclination': 0.0,
        'delta_t': 1.0 / sample_rate,
        'f_lower': 15.0,
        'approximant': 'SEOBNRv4',
        'injection_time': 0.95
        # id does not have a default because it must be unique
    }

    # Specify the parameters that should be varied and the ranges (uniform)
    # For the chosen range consult
    # https://www.lsc-group.phys.uwm.edu/ligovirgo/cbcnote/O2/OfflineTuningVerificationInjections
    update_list = {
        'masses': [2., 50.],
        # 'injection_time': [0.5, 0.9],
        'distance': [400., 800.]
    }

    # Collect everything in a big meta config dictionary
    meta_config = {
        'n_samples': n_samples,
        'duration': duration,
        'sample_rate': sample_rate,
        'default_parameters': default_parameters,
        'update_list': update_list,
    }

    with open(output_file, 'w') as f:
        json.dump(meta_config, f, sort_keys=True, indent=2)
    print("DONE -- Saved as {}".format(output_file))


if __name__ == '__main__':
    import datetime
    timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
    new_dir = os.path.join(os.getcwd(), timestamp)
    print("Create new folder ", new_dir)
    os.makedirs(new_dir)

    meta_config_file = os.path.join(new_dir, 'config.json')
    sample_config_file = os.path.join(new_dir, 'sample_config.json')
    sample_file = os.path.join(new_dir, 'samples.h5')

    generate_meta_config(meta_config_file)

    data_generation_pipeline(meta_config_file,
                             sample_config_file,
                             sample_file)
